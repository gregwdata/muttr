<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>muttr · Give your worries a world tour</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Plus+Jakarta+Sans:wght@500;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/maps/modules/map.js"></script>
    <style>
      html {
        scroll-behavior: smooth;
      }

      :root {
        color-scheme: dark;
        --bg: radial-gradient(circle at 10% -10%, #1f2937, #0f172a 45%, #020617 85%);
        --accent: linear-gradient(120deg, #f97316, #f43f5e, #6366f1);
        --glass: rgba(15, 23, 42, 0.7);
        --border: rgba(148, 163, 184, 0.28);
        --text: #f8fafc;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: var(--bg);
        color: var(--text);
        overflow-x: hidden;
      }

      a {
        color: inherit;
        text-decoration: none;
      }

      code {
        font-family: 'JetBrains Mono', 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid rgba(148, 163, 184, 0.18);
        padding: 0.1rem 0.35rem;
        border-radius: 6px;
        font-size: 0.95em;
      }

      header {
        position: sticky;
        top: 0;
        z-index: 5;
        backdrop-filter: blur(16px);
        background: rgba(2, 6, 23, 0.7);
        border-bottom: 1px solid rgba(148, 163, 184, 0.14);
      }

      .nav {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1.5rem;
        padding: 1.2rem clamp(1.5rem, 5vw, 4rem);
        max-width: 1200px;
        margin: 0 auto;
      }

      .brand {
        font-family: "Plus Jakarta Sans", "Inter", system-ui, sans-serif;
        font-size: 1.25rem;
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      .nav-links {
        display: flex;
        gap: clamp(1rem, 3vw, 2rem);
        font-size: 0.95rem;
        opacity: 0.82;
      }

      .cta-button,
      .pill-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 0.85rem 1.8rem;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        background: var(--accent);
        color: white;
        box-shadow: 0 24px 45px rgba(99, 102, 241, 0.35);
        transition: transform 0.18s ease, box-shadow 0.18s ease;
      }

      .pill-button.secondary {
        background: rgba(148, 163, 184, 0.12);
        color: var(--text);
        box-shadow: none;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      .cta-button:hover,
      .pill-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 28px 55px rgba(244, 63, 94, 0.35);
      }

      .cta-button:link,
      .cta-button:visited,
      .pill-button:link,
      .pill-button:visited {
        color: inherit;
      }

      main {
        position: relative;
      }

      #site-content {
        transition: filter 0.35s ease, transform 0.35s ease;
      }

      body.modal-open #site-content {
        filter: blur(18px) saturate(0.85);
        transform: scale(0.99);
        pointer-events: none;
        user-select: none;
      }

      .hero {
        padding: clamp(5rem, 12vw, 9rem) clamp(1.5rem, 6vw, 6rem) clamp(5rem, 10vw, 8rem);
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 3rem;
        align-items: center;
        max-width: 1200px;
        margin: 0 auto;
      }

      .hero-copy h1 {
        font-size: clamp(2.8rem, 6vw, 4.8rem);
        margin: 0 0 1.25rem;
        font-weight: 800;
        letter-spacing: -0.02em;
      }

      .hero-copy p {
        font-size: clamp(1.05rem, 2.4vw, 1.35rem);
        line-height: 1.7;
        max-width: 520px;
        margin: 0 0 2rem;
        color: rgba(226, 232, 240, 0.9);
      }

      .hero-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        background: rgba(148, 163, 184, 0.14);
        border-radius: 999px;
        padding: 0.5rem 1.1rem;
        font-size: 0.85rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      .hero-card {
        background: rgba(15, 23, 42, 0.7);
        border-radius: 24px;
        padding: 2rem;
        border: 1px solid rgba(99, 102, 241, 0.18);
        box-shadow: 0 40px 80px rgba(15, 23, 42, 0.6);
        position: relative;
        overflow: hidden;
        isolation: isolate;
      }

      .hero-card::before {
        content: "";
        position: absolute;
        inset: -30% -40% auto;
        height: 70%;
        background: radial-gradient(circle at center, rgba(244, 114, 182, 0.45), rgba(99, 102, 241, 0));
        z-index: -1;
      }

      .hero-card h2 {
        font-size: 1.2rem;
        font-weight: 600;
        margin: 0 0 1.2rem;
      }

      .hero-card ul {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 1.1rem;
      }

      .hero-card li {
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.14);
        padding: 1rem 1.2rem;
        border-radius: 18px;
        font-size: 0.95rem;
        line-height: 1.6;
        display: grid;
        gap: 0.25rem;
      }

      .hero-card strong {
        font-family: "Plus Jakarta Sans", "Inter", sans-serif;
        font-weight: 700;
        font-size: 0.95rem;
        letter-spacing: 0.02em;
        color: rgba(244, 244, 255, 0.95);
      }

      .section {
        padding: clamp(4rem, 9vw, 7rem) clamp(1.5rem, 6vw, 6rem);
        max-width: 1200px;
        margin: 0 auto;
      }

      .section h2 {
        font-size: clamp(2.1rem, 4vw, 3.2rem);
        margin: 0 0 1.2rem;
      }

      .section p.lead {
        max-width: 640px;
        font-size: clamp(1rem, 2vw, 1.2rem);
        line-height: 1.7;
        color: rgba(226, 232, 240, 0.85);
        margin: 0 0 2.8rem;
      }

      .feature-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1.8rem;
      }

      .feature-card {
        background: rgba(15, 23, 42, 0.68);
        border-radius: 22px;
        padding: 1.8rem;
        border: 1px solid rgba(148, 163, 184, 0.18);
        position: relative;
        overflow: hidden;
      }

      .feature-card::after {
        content: "";
        position: absolute;
        inset: auto -30% -30% auto;
        width: 160px;
        height: 160px;
        background: radial-gradient(circle at center, rgba(99, 102, 241, 0.3), transparent 70%);
        opacity: 0.65;
        pointer-events: none;
      }

      .feature-card h3 {
        margin: 0 0 0.75rem;
        font-size: 1.15rem;
      }

      .feature-card p {
        margin: 0;
        font-size: 0.95rem;
        line-height: 1.65;
        color: rgba(226, 232, 240, 0.82);
      }

      .tech-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: clamp(1.5rem, 3vw, 2.5rem);
        margin-top: 2.8rem;
      }

      .tech-card {
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(99, 102, 241, 0.2);
        border-radius: 24px;
        padding: 2rem;
        box-shadow: 0 35px 60px rgba(2, 6, 23, 0.5);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        position: relative;
      }

      .tech-card::after {
        content: "";
        position: absolute;
        inset: auto auto -20% -20%;
        width: 140px;
        height: 140px;
        background: radial-gradient(circle at center, rgba(244, 114, 182, 0.3), transparent 70%);
        opacity: 0.6;
        pointer-events: none;
      }

      .tech-card h3 {
        margin: 0;
        font-size: 1.15rem;
      }

      .tech-card p,
      .tech-card li {
        color: rgba(226, 232, 240, 0.88);
        line-height: 1.65;
      }

      .tech-card ul {
        margin: 0;
        padding-left: 1.2rem;
        display: grid;
        gap: 0.55rem;
      }

      .tech-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        background: rgba(148, 163, 184, 0.18);
        padding: 0.4rem 0.85rem;
        border-radius: 999px;
      }

      .stat-band {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 2.5rem;
        margin-top: 3.5rem;
      }

      .stat {
        background: rgba(15, 23, 42, 0.55);
        border-radius: 24px;
        padding: 1.8rem;
        border: 1px solid rgba(99, 102, 241, 0.22);
        text-align: center;
      }

      .stat strong {
        display: block;
        font-size: clamp(2rem, 5vw, 3rem);
        font-weight: 700;
        font-family: "Plus Jakarta Sans", "Inter", sans-serif;
      }

      .testimonial-wrap {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 2rem;
      }

      .testimonial {
        background: rgba(15, 23, 42, 0.68);
        border-radius: 24px;
        padding: 2rem;
        border: 1px solid rgba(244, 63, 94, 0.18);
        position: relative;
      }

      .testimonial p {
        font-size: 1.05rem;
        line-height: 1.75;
        margin: 0 0 1.5rem;
      }

      .testimonial span {
        font-size: 0.9rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        opacity: 0.7;
      }

      .timeline {
        display: grid;
        gap: 1.8rem;
        margin-top: 3rem;
      }

      .timeline-step {
        display: grid;
        grid-template-columns: minmax(120px, 220px) 1fr;
        gap: 2rem;
        align-items: start;
        background: rgba(15, 23, 42, 0.6);
        padding: 1.8rem;
        border-radius: 24px;
        border: 1px solid rgba(148, 163, 184, 0.16);
      }

      .timeline-step h3 {
        margin: 0;
        font-size: 1rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        opacity: 0.75;
      }

      .timeline-step p {
        margin: 0;
        font-size: 1.05rem;
        line-height: 1.7;
        color: rgba(226, 232, 240, 0.84);
      }

      .pricing {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 2rem;
      }

      .pricing-card {
        background: rgba(15, 23, 42, 0.7);
        border-radius: 26px;
        padding: 2.4rem 2rem;
        border: 1px solid rgba(99, 102, 241, 0.2);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .pricing-card.highlight {
        border: 1px solid rgba(236, 72, 153, 0.45);
        box-shadow: 0 40px 70px rgba(236, 72, 153, 0.25);
      }

      .pricing-card h3 {
        font-size: 1.4rem;
        margin: 0;
      }

      .price-tag {
        font-size: clamp(2rem, 4vw, 3rem);
        font-weight: 700;
        font-family: "Plus Jakarta Sans", "Inter", sans-serif;
      }

      .pricing-card ul {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.9rem;
        color: rgba(226, 232, 240, 0.85);
        font-size: 0.95rem;
      }

      .relay-section {
        padding-bottom: clamp(5rem, 10vw, 8rem);
      }

      .relay-section h2 {
        text-align: center;
      }

      .relay-section p.lead {
        margin: 0 auto 3rem;
        text-align: center;
      }

      .relay-app {
        background: radial-gradient(circle at top left, #1f2937, #111827 50%, #0b1120);
        border: 1px solid rgba(148, 163, 184, 0.18);
        border-radius: 32px;
        padding: clamp(1.5rem, 3vw, 2.5rem);
        box-shadow: 0 40px 90px rgba(2, 6, 23, 0.85);
        color: #f9fafb;
      }

      .relay-app__header {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        margin-bottom: 2rem;
      }

      .relay-app__header h3 {
        margin: 0;
        font-size: clamp(1.8rem, 3vw, 2.6rem);
      }

      .relay-app__grid {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        align-items: start;
      }

      .relay-app__panel {
        background: rgba(15, 23, 42, 0.72);
        border: 1px solid rgba(148, 163, 184, 0.18);
        border-radius: 16px;
        padding: 1.25rem;
        box-shadow: 0 25px 45px rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(16px);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .relay-app textarea {
        min-height: 240px;
        resize: vertical;
        width: 100%;
        padding: 0.75rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.6);
        color: inherit;
        font-size: 0.95rem;
        line-height: 1.5;
        font-family: "Iosevka", "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", Menlo,
          monospace;
        white-space: pre-wrap;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .relay-app textarea.compact {
        min-height: 120px;
      }

      .relay-app textarea.relay-seed--locked {
        background: rgba(15, 23, 42, 0.4);
        border-color: rgba(148, 163, 184, 0.35);
        cursor: not-allowed;
      }

      .relay-app__panel--wide {
        grid-column: 1 / -1;
      }

      .relay-app .text-input {
        width: 100%;
        padding: 0.75rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.6);
        color: inherit;
        font-size: 0.95rem;
        line-height: 1.4;
        font-family: "Iosevka", "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", Menlo,
          monospace;
      }

      .relay-app .suggestion-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.25rem;
      }

      .relay-app .suggestion-buttons button {
        white-space: nowrap;
      }

      .relay-app button {
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1.5rem;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
        background: linear-gradient(120deg, #f97316, #ec4899);
        color: white;
        box-shadow: 0 18px 30px rgba(236, 72, 153, 0.35);
      }

      .relay-app button:hover:not([disabled]) {
        transform: translateY(-1px);
        box-shadow: 0 20px 40px rgba(236, 72, 153, 0.45);
      }

      .relay-app button.secondary-button {
        background: rgba(15, 23, 42, 0.55);
        color: #f97316;
        border: 1px solid rgba(249, 115, 22, 0.4);
        box-shadow: none;
        padding: 0.6rem 1.1rem;
      }

      .relay-app button.secondary-button.suggestion-button {
        background: rgba(249, 115, 22, 0.15);
        color: rgba(249, 115, 22, 0.85);
        border-color: rgba(249, 115, 22, 0.35);
      }

      .relay-app button.secondary-button:hover:not([disabled]) {
        box-shadow: 0 12px 22px rgba(249, 115, 22, 0.25);
      }

      .audio-input-row {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 0.5rem;
      }

      .label-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }

      .label-row label {
        margin: 0;
      }

      .relay-app button.audio-button {
        width: 48px;
        height: 48px;
        min-width: 48px;
        padding: 0;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: rgba(99, 102, 241, 0.15);
        border: 1px solid rgba(99, 102, 241, 0.35);
        box-shadow: none;
        color: rgba(191, 219, 254, 0.95);
      }

      .relay-app button.audio-button svg {
        width: 20px;
        height: 20px;
        fill: currentColor;
      }

      .relay-app button.audio-button.audio-button--compact {
        width: 36px;
        height: 36px;
        min-width: 36px;
      }

      .relay-app button.audio-button.is-recording {
        background: rgba(239, 68, 68, 0.22);
        border-color: rgba(248, 113, 113, 0.65);
        color: #fecaca;
        box-shadow: 0 10px 16px rgba(239, 68, 68, 0.25);
      }

      .relay-app button.audio-button.is-processing {
        background: rgba(59, 130, 246, 0.2);
        border-color: rgba(147, 197, 253, 0.7);
        color: #dbeafe;
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
        animation: audioPulse 1.4s ease-in-out infinite;
      }

      @keyframes audioPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.45);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
        }
      }

      .relay-app button.audio-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        animation: none;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .relay-app button[disabled] {
        cursor: progress;
        opacity: 0.65;
        box-shadow: none;
      }

      .relay-app .controls {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .hop-table-wrapper {
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(2, 6, 23, 0.45);
        overflow: hidden;
      }

      .hop-table-scroll {
        max-height: 300px;
        overflow: auto;
      }

      table.hop-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.9rem;
      }

      table.hop-table thead {
        position: sticky;
        top: 0;
        background: rgba(15, 23, 42, 0.85);
        backdrop-filter: blur(8px);
        z-index: 1;
      }

      table.hop-table th,
      table.hop-table td {
        padding: 0.65rem 0.75rem;
        text-align: left;
        border-bottom: 1px solid rgba(148, 163, 184, 0.14);
        white-space: nowrap;
      }

      table.hop-table td:nth-child(1) {
        font-weight: 600;
        color: #fbbf24;
      }

      table.hop-table td:nth-child(3) {
        font-variant-numeric: tabular-nums;
      }

      table.hop-table tbody tr:last-child td {
        border-bottom: none;
      }

      .relay-app .stack {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .relay-app .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.35rem 0.75rem;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        font-size: 0.8rem;
        background: rgba(15, 23, 42, 0.55);
      }

      .relay-app .notice {
        font-size: 0.8rem;
        opacity: 0.75;
        margin: 0;
      }

      .relay-app label {
        font-size: 0.85rem;
        font-weight: 600;
        letter-spacing: 0.01em;
      }

      .relay-app .dev-note {
        font-size: 0.75rem;
        opacity: 0.65;
        margin: 0;
      }

      .relay-app .error-message {
        margin: 0;
        font-size: 0.85rem;
        color: #fca5a5;
      }

      .relay-app pre {
        margin: 0;
        overflow: auto;
        font-size: 0.85rem;
        line-height: 1.5;
        background: rgba(15, 23, 42, 0.6);
        border-radius: 12px;
        padding: 0.75rem;
        max-height: 360px;
      }

      .relay-app .log-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-height: 320px;
        overflow: auto;
      }

      .relay-app .log-item {
        font-family: "Iosevka", "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", Menlo,
          monospace;
        font-size: 0.8rem;
        white-space: pre-wrap;
        word-break: break-word;
        background: rgba(15, 23, 42, 0.55);
        border-radius: 12px;
        padding: 0.65rem;
      }

      #relay-map {
        width: 100%;
        min-height: 320px;
        height: clamp(320px, 35vw, 500px);
        border-radius: 16px;
        overflow: hidden;
        border: 1px solid rgba(148, 163, 184, 0.18);
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.35);
      }

      #relay-map .highcharts-container {
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      #relay-map .highcharts-background,
      #relay-map .highcharts-plot-background {
        fill: rgba(2, 6, 23, 0.9);
      }

      #relay-map .highcharts-mapline-series .highcharts-graph {
        filter: drop-shadow(0 0 8px rgba(250, 204, 21, 0.35));
      }

      .relay-app__footer {
        opacity: 0.6;
        font-size: 0.75rem;
        text-align: center;
        margin-top: 2rem;
      }

      .footer {
        padding: 3rem clamp(1.5rem, 6vw, 6rem);
        border-top: 1px solid rgba(148, 163, 184, 0.12);
        text-align: center;
        color: rgba(226, 232, 240, 0.65);
        font-size: 0.9rem;
      }

      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(2, 6, 23, 0.72);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: clamp(1rem, 3vw, 2rem);
        z-index: 10;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease;
      }

      .modal-backdrop.visible {
        opacity: 1;
        visibility: visible;
      }

      .modal {
        width: min(90vw, 960px);
        height: min(90vh, 780px);
        background: rgba(15, 23, 42, 0.92);
        border-radius: 32px;
        border: 1px solid rgba(244, 63, 94, 0.4);
        box-shadow: 0 60px 120px rgba(15, 23, 42, 0.85);
        padding: clamp(2rem, 4vw, 3.5rem);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        position: relative;
        overflow: hidden;
        isolation: isolate;
      }

      .modal::before,
      .modal::after {
        content: "";
        position: absolute;
        border-radius: 999px;
        filter: blur(0px);
        pointer-events: none;
      }

      .modal::before {
        width: 420px;
        height: 420px;
        background: radial-gradient(circle at center, rgba(244, 114, 182, 0.4), rgba(99, 102, 241, 0));
        top: -120px;
        right: -160px;
      }

      .modal::after {
        width: 360px;
        height: 360px;
        background: radial-gradient(circle at center, rgba(249, 115, 22, 0.35), transparent 70%);
        bottom: -140px;
        left: -120px;
      }

      .modal h2 {
        font-size: clamp(2rem, 4vw, 3.2rem);
        margin: 0;
        font-weight: 800;
        letter-spacing: -0.02em;
      }

      .modal p {
        margin: 0;
        font-size: clamp(1rem, 2.2vw, 1.2rem);
        line-height: 1.8;
        color: rgba(226, 232, 240, 0.88);
      }

      .modal-content {
        display: grid;
        gap: 1.4rem;
        overflow-y: auto;
      }

      .modal-actions {
        margin-top: auto;
        display: flex;
        justify-content: flex-end;
      }

      .modal-quote {
        font-size: 1rem;
        line-height: 1.7;
        color: rgba(226, 232, 240, 0.75);
        border-left: 3px solid rgba(244, 63, 94, 0.45);
        padding-left: 1rem;
      }

      .logo-cloud {
        display: flex;
        flex-wrap: wrap;
        gap: 1.8rem;
        align-items: center;
        opacity: 0.55;
        text-transform: uppercase;
        letter-spacing: 0.22em;
        font-size: 0.75rem;
      }

      @media (max-width: 720px) {
        .nav {
          flex-direction: column;
          align-items: flex-start;
        }

        .nav-links {
          flex-wrap: wrap;
        }

        .timeline-step {
          grid-template-columns: 1fr;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          animation-duration: 0.001ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.001ms !important;
          scroll-behavior: auto !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="modal-backdrop" data-modal-backdrop hidden>
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title" data-modal>
        <div class="modal-content">
          <span class="hero-badge">New from the mutterverse</span>
          <h2 id="modal-title">Unpack your headspace into a globe-trotting AI confidant</h2>
          <p>
            You pace. You mutter. The concerns ricochet against the walls of your skull. Let muttr take the burden.
            We ship every anxious note on a world tour of language models who pace, fret, and loop until clarity drops back into your lap.
          </p>
          <p class="modal-quote">
            “We used to host daily venting standups. Now muttr’s relay does the muttering for us while the team ships.” — Ops lead, Starlight Freight
          </p>
          <p>
            When you close this window you’ll meet a full-stack SaaS landing page ready to convince your boss, your procurement team, and the restless voice in your head.
            Because sometimes the best way to quiet the inner monologue is to give it a passport and let it run laps around the planet.
          </p>
        </div>
        <div class="modal-actions">
          <button class="cta-button" type="button" data-close-modal>Unburden Yourself</button>
        </div>
      </div>
    </div>
    <header>
      <nav class="nav">
        <div class="brand">muttr relay</div>
        <div class="nav-links">
          <a href="#features">Features</a>
          <a href="#technology">Technology</a>
          <a href="#method">How it Works</a>
          <a href="#social-proof">Testimonials</a>
          <a href="#pricing">Pricing</a>
        </div>
        <a class="pill-button" href="#relay-app">Launch muttr</a>
      </nav>
    </header>
    <main id="site-content">
      <section class="hero">
        <div class="hero-copy">
          <div class="hero-badge">Let the AI do the pacing</div>
          <h1>Give your worries a frequent flyer program.</h1>
          <p>
            Your brain doesn’t need another midnight sprint. muttr offloads the inner muttering to an orbiting relay of AI confidants, sending every concern on a passport-stamped world tour so you can stay focused on the work that matters.
          </p>
          <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
            <a class="cta-button" href="#relay-app">Launch muttr</a>
            <a
              class="pill-button secondary"
              href="#relay-app"
              data-relay-message="Like I'm going to read another lame AI startup's pitch deck. I need to remember to jam it through Grok and get a summary."
              >Download the deck</a
            >
          </div>
        </div>
        <aside class="hero-card">
          <h2>The ritual in three breaths</h2>
          <ul>
            <li>
              <strong>Whisper into muttr.</strong>
              Drop every anxious task, scenario, or intrusive what-if into the relay. No formatting required.
            </li>
            <li>
              <strong>Let the circuit pace.</strong>
              Your burdens hitchhike across multiple hemispheres, where each persona refines and reports like a restless inner monologue.
            </li>
            <li>
              <strong>Receive calm clarity.</strong>
              muttr returns with prioritised next steps and a log of everywhere your burdens vacationed.
            </li>
          </ul>
        </aside>
      </section>

      <section class="section" id="features">
        <h2>Built for teams who think faster than their anxieties.</h2>
        <p class="lead">
          muttr is the only B2B platform that treats worry like operational debt. Offload the head-noise and let our relay of synthetic mutterers iterate until the signal is crystal clear.
        </p>
        <div class="feature-grid">
          <article class="feature-card">
            <h3>Global concern choreography</h3>
            <p>
              Every whisper tours sunrise and sunset zones in a single lap. Your thoughts gain perspective while latency stays delightfully low.
            </p>
          </article>
          <article class="feature-card">
            <h3>Audit-ready muttering logs</h3>
            <p>
              Keep procurement happy with a narrative timeline of the relay’s pacing, complete with executive-ready annotations and decision rationales.
            </p>
          </article>
          <article class="feature-card">
            <h3>Anxiety load balancers</h3>
            <p>
              Smart load management keeps hot worries at the front of the queue while long-term dread simmers in the background.
            </p>
          </article>
          <article class="feature-card">
            <h3>Enterprise-grade catharsis</h3>
            <p>
              SOC 2-inspired safeguards meet a therapeutic level of overthinking. Finally, compliance and calm in a single platform.
            </p>
          </article>
        </div>
        <div class="stat-band">
          <div class="stat">
            <strong>92%</strong>
            of customers report fewer hallway mutters after their first relay.
          </div>
          <div class="stat">
            <strong>37 hrs</strong>
            average weekly worry time returned to productive flow states.
          </div>
          <div class="stat">
            <strong>Infinite laps</strong>
            circling the globe so your brain doesn’t have to.
          </div>
        </div>
      </section>

      <section class="section" id="technology">
        <h2>The technology that keeps your AI concerns circling the globe.</h2>
        <p class="lead">
          Each whisper you upload embarks on a multi-region relay that feels impossibly advanced without ever exposing the wiring.
          It’s the most efficient way to let software do the anxious walkabouts for you.
        </p>
        <div class="tech-grid">
          <article class="tech-card">
            <span class="tech-pill">Orbit fabric</span>
            <h3>World-tour routing fabric</h3>
            <p>
              Concerns leave your browser, catch red-eye flights across friendly data skies, and return with postcards from every time zone.
            </p>
            <ul>
              <li>Sunrise-to-sundown perspective resets on every lap</li>
              <li>Pan-hemispheric pacing that keeps the energy moving</li>
              <li>Hand-curated itinerary so latency feels like a deep breath</li>
            </ul>
          </article>
          <article class="tech-card">
            <span class="tech-pill">Signal cloud</span>
            <h3>Mutterboard telemetry</h3>
            <p>
              Instead of packet captures, you get lush storytelling dashboards that prove the relay paced around the planet for you.
            </p>
            <ul>
              <li>Color-coded pacing ribbons for leadership decks</li>
              <li>Vibe-rich annotations that explain every reframing</li>
              <li>Shareable proof that someone else is doing the worrying</li>
            </ul>
          </article>
          <article class="tech-card">
            <span class="tech-pill">Agentic relay</span>
            <h3>Offload the muttering, reclaim the strategy</h3>
            <p>
              A roaming cast of AI handlers—so agentic, much wow—picks up the anxious thread before you can even start pacing.
            </p>
            <ul>
              <li>Persona shifts keep every lap fresh</li>
              <li>Ambient tone calibration for exec, ops, or founder mode</li>
              <li>Pre-emptive pacing loops so plans arrive calm and complete</li>
            </ul>
          </article>
        </div>
      </section>

      <section class="section" id="method">
        <h2>How muttr turns restless thoughts into decisive motion.</h2>
        <p class="lead">
          Our pacing playbook keeps concerns moving until they transmute into action. Every lap adds clarity, context, and courage.
        </p>
        <div class="timeline">
          <div class="timeline-step">
            <h3>01 • Capture</h3>
            <p>
              Feed muttr the stream-of-consciousness you would normally mumble while walking laps around the office. Raw is welcome.
            </p>
          </div>
          <div class="timeline-step">
            <h3>02 • Circulate</h3>
            <p>
              Each AI persona rephrases, reframes, and reprioritises. It’s your inner monologue, but now it has frequent flyer miles and a remit to deliver.
            </p>
          </div>
          <div class="timeline-step">
            <h3>03 • Clarify</h3>
            <p>
              The relay returns with an action plan, a synopsis, and a highlight reel of the muttering performed on your behalf.
            </p>
          </div>
          <div class="timeline-step">
            <h3>04 • Close the loop</h3>
            <p>
              Every concern loops back into the next relay run, meaning nothing lingers in your head longer than it wants to.
            </p>
          </div>
        </div>
      </section>

      <section class="section" id="social-proof">
        <h2>Teams worldwide are letting muttr pace in their place.</h2>
        <p class="lead">
          Whether you’re shipping rocket telemetry or managing remote IT incidents, muttr keeps the background muttering productive and out of your skull.
        </p>
        <div class="logo-cloud">
          <span>NovaOrbit</span>
          <span>Permafrost Logistics</span>
          <span>GlowStack Labs</span>
          <span>Cobalt &amp; Co.</span>
          <span>Riverly Finance</span>
          <span>Synapse Yard</span>
        </div>
        <div class="testimonial-wrap">
          <blockquote class="testimonial">
            <p>
              “muttr is the only vendor I’ve seen that understands the cost of a CTO muttering down the hallway. Our roadmap stays crisp because the relay never stops pacing for us.”
            </p>
            <span>Chief Product Officer · Glimmerworks</span>
          </blockquote>
          <blockquote class="testimonial">
            <p>
              “Customer escalations used to live in my head. Now I toss them into muttr, grab a coffee, and come back to a fully reasoned response drafted by an AI that already paced the lobby twice.”
            </p>
            <span>Director of CX · Nimbus Support</span>
          </blockquote>
          <blockquote class="testimonial">
            <p>
              “We replaced three parallel Slack rants with a single muttr loop. The AI mutters, we execute. Morale has never been higher.”
            </p>
            <span>Engineering Manager · Copperline Systems</span>
          </blockquote>
        </div>
      </section>

      <section class="section" id="pricing">
        <h2>Choose how much muttering you want off your plate.</h2>
        <p class="lead">
          All plans include globe-spanning relays, audit trails, and a soothing sense that someone else is pacing on your behalf.
        </p>
        <div class="pricing">
          <article class="pricing-card">
            <h3>Starter</h3>
            <div class="price-tag">$29</div>
            <p>per mutterer / month</p>
            <ul>
              <li>Unlimited concern capture</li>
              <li>Single relay chain</li>
              <li>Weekly mutter summaries</li>
            </ul>
            <a
              class="pill-button secondary"
              href="#relay-app"
              data-relay-message="Ugh, another enterprise sales rep. There goes my lunch break."
              >Book a trial</a
            >
          </article>
          <article class="pricing-card highlight">
            <h3>Growth</h3>
            <div class="price-tag">$79</div>
            <p>per mutterer / month</p>
            <ul>
              <li>Dual relay circuits with failover</li>
              <li>API access to muttering transcripts</li>
              <li>Escalation routing for urgent anxieties</li>
            </ul>
            <a
              class="cta-button"
              href="#relay-app"
              data-relay-message="Can't believe I'm stuck on a discovery call instead of shipping my roadmap."
              >Talk to sales</a
            >
          </article>
          <article class="pricing-card">
            <h3>Enterprise</h3>
            <div class="price-tag">Let’s chat</div>
            <p>bespoke calm pricing</p>
            <ul>
              <li>On-prem pacing compliance reviews</li>
              <li>Private global pacing constellations</li>
              <li>Dedicated chief muttering officer</li>
            </ul>
            <a
              class="pill-button secondary"
              href="#relay-app"
              data-relay-message="Do I really need to sit through another sales briefing before I can breathe?"
              >Schedule a briefing</a
            >
          </article>
        </div>
      </section>

      <section class="section" style="text-align: center;">
        <h2>Ready to let your brain breathe?</h2>
        <p class="lead" style="margin: 0 auto 2.5rem;">
          Step into the relay. We’ll pace, mutter, and loop until your toughest worries report back with answers.
        </p>
        <button class="cta-button" type="button" data-open-modal>Initiate the next lap</button>
      </section>

      <section class="section relay-section" id="relay-app">
        <div class="relay-app" id="relay-app-module">
          <header class="relay-app__header">
            <h3>muttr</h3>
          </header>
          <div class="relay-app__grid">
            <section class="relay-app__panel">
              <h2>Place your concerns here</h2>
              <div class="audio-input-row">
                <button
                  type="button"
                  class="audio-button"
                  data-audio-target="seed"
                  title="Audio input"
                  aria-label="Capture audio for your main todo list"
                >
                  <svg viewBox="0 0 24 24" role="img" aria-hidden="true">
                    <path
                      d="M12 15.5a3.5 3.5 0 0 0 3.5-3.5V6a3.5 3.5 0 0 0-7 0v6a3.5 3.5 0 0 0 3.5 3.5zm6-3.75a.75.75 0 1 1 1.5 0 6.5 6.5 0 0 1-6.25 6.49V21h2.75a.75.75 0 0 1 0 1.5h-6.5a.75.75 0 0 1 0-1.5H12v-2.76A6.5 6.5 0 0 1 6 11.75a.75.75 0 0 1 1.5 0 5 5 0 1 0 10 0z"
                    ></path>
                  </svg>
                  <span class="sr-only">Capture audio for your main todo list</span>
                </button>
              </div>
              <textarea id="relay-seed" placeholder="List the burdens weighing you down...">- Buy groceries
- Eat lunch
- Mow grass
- Do Taxes</textarea>
              <div class="label-row">
                <label for="relay-update-input">Update your list</label>
                <button
                  type="button"
                  class="audio-button audio-button--compact"
                  data-audio-target="update"
                  title="Audio input for updates"
                  aria-label="Capture audio for your list updates"
                >
                  <svg viewBox="0 0 24 24" role="img" aria-hidden="true">
                    <path
                      d="M12 15.5a3.5 3.5 0 0 0 3.5-3.5V6a3.5 3.5 0 0 0-7 0v6a3.5 3.5 0 0 0 3.5 3.5zm6-3.75a.75.75 0 1 1 1.5 0 6.5 6.5 0 0 1-6.25 6.49V21h2.75a.75.75 0 0 1 0 1.5h-6.5a.75.75 0 0 1 0-1.5H12v-2.76A6.5 6.5 0 0 1 6 11.75a.75.75 0 0 1 1.5 0 5 5 0 1 0 10 0z"
                    ></path>
                  </svg>
                  <span class="sr-only">Capture audio for your list updates</span>
                </button>
              </div>
              <form id="relay-update-form" class="stack">
                <input
                  id="relay-update-input"
                  class="text-input"
                  type="text"
                  placeholder="Share what changed since the last lap"
                  autocomplete="off"
                />
                <div class="controls">
                  <button type="submit" class="secondary-button">Submit update</button>
                </div>
              </form>
              <div class="suggestion-buttons">
                <button type="button" class="secondary-button suggestion-button" data-suggestion="I completed the first item">
                  I completed the first item
                </button>
                <button type="button" class="secondary-button suggestion-button" data-suggestion="And my cat needs to be spayed.">
                  And my cat needs to be spayed.
                </button>
                <button type="button" class="secondary-button suggestion-button" data-suggestion="Time is closing in on me">
                  Time is closing in on me
                </button>
              </div>
              <p class="dev-note" id="relay-update-note">
                Submitted updates are queued and will join the next hop in the circuit.
              </p>
              <p id="relay-error" class="error-message" hidden></p>
              <div class="controls">
                <button id="relay-start">Start Muttring</button>
                <button id="relay-stop" disabled>Stop</button>
                <span class="badge">iteration: <span id="relay-iterations">0</span></span>
                <span class="badge">status: <span id="relay-status">idle</span></span>
              </div>
            </section>

            <section class="relay-app__panel">
              <h2>Watch AI haul your burdens around Earth</h2>
              <p class="dev-note">Each leg renders using the latest round trip timestamps. Watch Your Issues trace the last lap in real time.</p>
              <div id="relay-map" role="img" aria-label="World map showing the muttr hop path"></div>
            </section>

            <section class="relay-app__panel relay-app__panel--wide">
              <h2>Live hop manifest</h2>
              <p class="dev-note">Newest hops land at the top so you can follow the payload’s reverse-chronological gossip.</p>
              <div class="hop-table-wrapper" role="region" aria-live="polite" aria-label="Live hop telemetry">
                <div class="hop-table-scroll">
                  <table class="hop-table">
                    <thead>
                      <tr>
                        <th scope="col">Relay Station</th>
                        <th scope="col">Direction</th>
                        <th scope="col">Duration</th>
                        <th scope="col">Timestamp</th>
                      </tr>
                    </thead>
                    <tbody id="relay-hop-table"></tbody>
                  </table>
                </div>
              </div>
            </section>
          </div>
          <footer class="relay-app__footer">
            There is no storage. Only vibes. Powered by Azure Functions + OpenRouter.
          </footer>
        </div>
      </section>
    </main>
    <footer class="footer">
      muttr relays are powered by Azure Functions, OpenRouter, and an unhealthy commitment to doing the worrying for you.
      There is still no database. Only vibes.
    </footer>
    <script>
      const body = document.body;
      const backdrop = document.querySelector('[data-modal-backdrop]');
      const modal = document.querySelector('[data-modal]');
      const closeButton = document.querySelector('[data-close-modal]');
      const openModalButtons = document.querySelectorAll('[data-open-modal]');

      function showModal() {
        if (!backdrop) return;
        backdrop.hidden = false;
        requestAnimationFrame(() => {
          backdrop.classList.add('visible');
          body.classList.add('modal-open');
        });
      }

      function hideModal() {
        if (!backdrop) return;
        backdrop.classList.remove('visible');
        body.classList.remove('modal-open');
        const handleTransitionEnd = () => {
          backdrop.hidden = true;
          backdrop.removeEventListener('transitionend', handleTransitionEnd);
        };
        backdrop.addEventListener('transitionend', handleTransitionEnd, { once: true });
      }

      if (closeButton) {
        closeButton.addEventListener('click', hideModal);
      }

      if (backdrop) {
        backdrop.addEventListener('click', (event) => {
          if (event.target === event.currentTarget) {
            hideModal();
          }
        });
      }

      if (modal) {
        modal.addEventListener('click', (event) => {
          event.stopPropagation();
        });
      }

      openModalButtons.forEach((button) => {
        button.addEventListener('click', showModal);
      });

      const launchModalOnLoad = () => showModal();

      window.addEventListener('DOMContentLoaded', launchModalOnLoad);
      window.addEventListener('pageshow', (event) => {
        if (event.persisted) {
          launchModalOnLoad();
        }
      });
    </script>
    <script>
      (function initRelayApp() {
        const relayApp = document.getElementById('relay-app-module');
        if (!relayApp) return;

        const seed = relayApp.querySelector('#relay-seed');
        const updateForm = relayApp.querySelector('#relay-update-form');
        const updateInput = relayApp.querySelector('#relay-update-input');
        const suggestionButtons = relayApp.querySelectorAll('.suggestion-button');
        const updateNote = relayApp.querySelector('#relay-update-note');
        const startBtn = relayApp.querySelector('#relay-start');
        const stopBtn = relayApp.querySelector('#relay-stop');
        const iterationsEl = relayApp.querySelector('#relay-iterations');
        const statusEl = relayApp.querySelector('#relay-status');
        const hopTableBody = relayApp.querySelector('#relay-hop-table');
        const errorEl = relayApp.querySelector('#relay-error');
        const mapEl = relayApp.querySelector('#relay-map');
        const relaySection = document.getElementById('relay-app');
        const relayMessageButtons = document.querySelectorAll('[data-relay-message]');
        const hopTableHistory = [];
        const hopTableKeySet = new Set();
        const HOP_TABLE_HISTORY_LIMIT = 200;
        const audioButtons = relayApp.querySelectorAll('[data-audio-target]');
        const seedAudioButton = relayApp.querySelector('[data-audio-target="seed"]');
        const updateAudioButton = relayApp.querySelector('[data-audio-target="update"]');
        const AUDIO_TRANSCRIBE_ENDPOINT = 'https://muttr-us-east.azurewebsites.net/api/transcribe-audio';
        const AUDIO_MAX_RECORDING_MS = 20000;
        const AudioContextCtor =
          typeof window !== 'undefined' ? window.AudioContext || window.webkitAudioContext : null;
        const audioState = {
          supported:
            typeof window !== 'undefined' &&
            typeof navigator !== 'undefined' &&
            !!navigator.mediaDevices &&
            typeof navigator.mediaDevices.getUserMedia === 'function' &&
            typeof window.MediaRecorder !== 'undefined' &&
            !!AudioContextCtor,
          mediaRecorder: null,
          stream: null,
          chunks: [],
          recordingButton: null,
          recordingTarget: null,
          stopTimer: null,
          audioContext: null
        };

        relayMessageButtons.forEach((cta) => {
          cta.addEventListener('click', (event) => {
            const message = cta.getAttribute('data-relay-message');
            if (event) {
              event.preventDefault();
            }
            if (message && seed) {
              seed.value = message;
              seed.dispatchEvent(new Event('input', { bubbles: true }));
              seed.focus();
            } else if (message && updateInput) {
              updateInput.value = message;
              updateInput.dispatchEvent(new Event('input', { bubbles: true }));
              updateInput.focus();
            }
            if (relaySection && relaySection.scrollIntoView) {
              relaySection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            if (typeof history !== 'undefined' && typeof history.replaceState === 'function') {
              history.replaceState(null, '', '#relay-app');
            } else if (typeof window !== 'undefined' && window.location) {
              window.location.hash = 'relay-app';
            }
          });
        });

        const HOP_COORDINATES = {
          'muttr-us-east': { label: 'US East · Virginia, USA', lat: 37.505, lng: -77.32 },
          'muttr-brazil': { label: 'Brazil · São Paulo', lat: -23.5505, lng: -46.6333 },
          'muttr-uk': { label: 'United Kingdom · London', lat: 51.5072, lng: -0.1276 },
          'muttr-singapore': { label: 'Singapore', lat: 1.3521, lng: 103.8198 },
          'muttr-sydney': { label: 'Australia · Sydney', lat: -33.8688, lng: 151.2093 }
        };

        const DEFAULT_ORB_POSITION = HOP_COORDINATES['muttr-us-east'];
        let lastKnownOrbPosition = DEFAULT_ORB_POSITION
          ? { lat: DEFAULT_ORB_POSITION.lat, lon: DEFAULT_ORB_POSITION.lng }
          : null;

        function sanitizeHopKey(value) {
          if (typeof value !== 'string') {
            return '';
          }
          const trimmed = value.trim();
          if (!trimmed) {
            return '';
          }
          const withoutSuffix = trimmed.replace(/-hop$/, '');
          if (HOP_COORDINATES[withoutSuffix]) {
            return withoutSuffix;
          }
          const prefixed = withoutSuffix.startsWith('muttr-')
            ? withoutSuffix
            : `muttr-${withoutSuffix}`;
          if (HOP_COORDINATES[prefixed]) {
            return prefixed;
          }
          return withoutSuffix;
        }

        const ORB_LABEL_PLAIN = 'Your\nIssues';
        const ORB_LABEL_HTML = 'Your<br/>Issues';

        const DEFAULT_ROUTE_SEQUENCE = [
          'muttr-us-east',
          'muttr-brazil',
          'muttr-uk',
          'muttr-singapore',
          'muttr-sydney',
          'muttr-singapore',
          'muttr-uk',
          'muttr-brazil',
          'muttr-us-east'
        ];

        const DEFAULT_ROUTE_POINTS = DEFAULT_ROUTE_SEQUENCE.map((hop) => {
          const detail = HOP_COORDINATES[hop];
          if (!detail) return null;
          return { hop, lat: detail.lat, lng: detail.lng };
        }).filter(Boolean);

        const FALLBACK_SEGMENT_DURATION_MS = 850;

        let defaultRouteGeometryCache = null;

        function getDefaultRouteGeometry() {
          if (!defaultRouteGeometryCache) {
            defaultRouteGeometryCache = buildRouteGeometry(DEFAULT_ROUTE_POINTS);
          }
          return defaultRouteGeometryCache;
        }

        const mapState = {
          chart: null,
          readyPromise: null,
          topologyPromise: null,
          animationFrame: null,
          animationToken: 0
        };

        function loadWorldTopology() {
          if (!mapState.topologyPromise) {
            mapState.topologyPromise = fetch('https://code.highcharts.com/mapdata/custom/world.topo.json')
              .then((response) => response.json())
              .catch((error) => {
                console.error('Failed to fetch Highcharts map data', error);
                mapState.topologyPromise = null;
                return null;
              });
          }
          return mapState.topologyPromise;
        }

        async function initMap() {
          if (!mapEl || typeof Highcharts === 'undefined') {
            return null;
          }
          if (mapState.chart) {
            return mapState.chart;
          }
          if (!mapState.readyPromise) {
            mapState.readyPromise = loadWorldTopology()
              .then((topology) => {
                if (!topology || !topology.objects) {
                  return null;
                }

                const hopData = buildHopSeriesData(new Set());

                mapState.chart = Highcharts.mapChart(mapEl, {
                  chart: {
                    map: topology,
                    backgroundColor: 'transparent',
                    style: {
                      fontFamily: '"Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif'
                    }
                  },
                  title: { text: null },
                  legend: { enabled: false },
                  credits: { enabled: false },
                  mapNavigation: {
                    enabled: true,
                    buttonOptions: {
                      align: 'right',
                      verticalAlign: 'bottom',
                      theme: {
                        fill: 'rgba(15, 23, 42, 0.85)',
                        stroke: 'rgba(148, 163, 184, 0.3)',
                        'stroke-width': 0.5,
                        style: { color: '#f8fafc' },
                        states: {
                          hover: {
                            fill: '#f97316',
                            style: { color: '#0f172a' }
                          }
                        }
                      }
                    }
                  },
                  tooltip: {
                    backgroundColor: 'rgba(15, 23, 42, 0.9)',
                    borderColor: 'rgba(148, 163, 184, 0.35)',
                    style: { color: '#f8fafc' },
                    useHTML: true,
                    formatter: function tooltipFormatter() {
                      if (this.series && this.series.userOptions && this.series.userOptions.id === 'orb-series') {
                        return `<strong>${ORB_LABEL_HTML}</strong><br/>Currently in-flight`;
                      }
                      if (this.point && this.point.name) {
                        return `<strong>${this.point.name}</strong>`;
                      }
                      return '';
                    }
                  },
                  series: [
                    {
                      type: 'map',
                      name: 'World',
                      mapData: topology,
                      nullColor: '#0f172a',
                      borderColor: 'rgba(148, 163, 184, 0.25)',
                      borderWidth: 0.4
                    },
                    {
                      type: 'mappoint',
                      id: 'hop-series',
                      name: 'Relay hops',
                      data: hopData,
                      dataLabels: {
                        enabled: false
                      }
                    },
                    {
                      type: 'mapline',
                      id: 'route-series',
                      data: getDefaultRouteGeometry(),
                      lineWidth: 1.5,
                      color: '#facc15',
                      dashStyle: 'ShortDash',
                      enableMouseTracking: false
                    },
                    {
                      type: 'mappoint',
                      id: 'orb-series',
                      name: ORB_LABEL_PLAIN,
                      data:
                        DEFAULT_ORB_POSITION
                          ? [
                              {
                                id: 'orb-point',
                                name: ORB_LABEL_PLAIN,
                                lat: DEFAULT_ORB_POSITION.lat,
                                lon: DEFAULT_ORB_POSITION.lng
                              }
                            ]
                          : [],
                      marker: {
                        radius: 10,
                        symbol: 'circle',
                        lineWidth: 0,
                        fillColor: {
                          radialGradient: { cx: 0.5, cy: 0.5, r: 0.7 },
                          stops: [
                            [0, 'rgba(254, 252, 232, 1)'],
                            [0.4, 'rgba(250, 204, 21, 0.9)'],
                            [0.8, 'rgba(251, 191, 36, 0.45)'],
                            [1, 'rgba(234, 179, 8, 0)']
                          ]
                        }
                      },
                      states: { hover: { enabled: false } },
                      enableMouseTracking: false
                    }
                  ]
                });

                return mapState.chart;
              })
              .catch((error) => {
                console.error('Failed to initialise Highcharts map', error);
                mapState.readyPromise = null;
                return null;
              });
          }

          return mapState.readyPromise;
        }

        function buildHopSeriesData(visitedHops) {
          return Object.entries(HOP_COORDINATES).map(([key, detail]) => {
            const active = visitedHops.has(key);
            const baseColor = active ? '#f97316' : '#94a3b8';
            return {
              id: key,
              name: `${detail.label} · ${key}`,
              lat: detail.lat,
              lon: detail.lng,
              color: baseColor,
              marker: {
                radius: active ? 6 : 4,
                symbol: 'circle',
                fillColor: baseColor,
                lineWidth: 1,
                lineColor: 'rgba(15, 23, 42, 0.9)'
              }
            };
          });
        }

        function syncMapWithPoints(points) {
          void initMap().then((chart) => {
            if (!chart) return;
            updateHopSeries(chart, points);
            updateRouteSeries(chart, points);
            chart.redraw();
          });
        }

        function updateHopSeries(chart, points) {
          const hopSeries = chart.get('hop-series');
          if (!hopSeries) return;
          const visited = new Set(points.map((point) => point.hop));
          hopSeries.setData(buildHopSeriesData(visited), false);
        }

        function updateRouteSeries(chart, points) {
          const routeSeries = chart.get('route-series');
          if (!routeSeries) return;
          const hasRoute = Array.isArray(points) && points.length >= 2;
          const data = hasRoute ? buildRouteGeometry(points) : getDefaultRouteGeometry();
          routeSeries.setData(data, false);
        }

        function buildRouteGeometry(points) {
          const data = [];
          for (let i = 1; i < points.length; i += 1) {
            const from = points[i - 1];
            const to = points[i];
            if (!from || !to) continue;
            if (!Number.isFinite(from.lat) || !Number.isFinite(from.lng)) continue;
            if (!Number.isFinite(to.lat) || !Number.isFinite(to.lng)) continue;
            data.push({
              id: `route-${i}`,
              geometry: {
                type: 'LineString',
                coordinates: buildGreatCircleCoordinates(from, to)
              }
            });
          }
          return data;
        }

        function buildGreatCircleCoordinates(from, to, steps = 48) {
          const coordinates = [];
          for (let i = 0; i <= steps; i += 1) {
            const t = i / steps;
            const position = interpolateGreatCircle(from, to, t);
            coordinates.push([position.lon, position.lat]);
          }
          return coordinates;
        }

        function buildTimestampTimeline(points) {
          if (!Array.isArray(points) || points.length === 0) {
            return [];
          }
          return points
            .filter((point) => Number.isFinite(point.timestampMs))
            .sort((a, b) => a.timestampMs - b.timestampMs);
        }

        function buildFallbackTimeline(points) {
          if (!Array.isArray(points) || points.length === 0) {
            return [];
          }
          const ordered = [];
          points.forEach((point) => {
            if (!point) return;
            const lat = typeof point.lat === 'number' ? point.lat : null;
            const lng =
              typeof point.lng === 'number'
                ? point.lng
                : typeof point.lon === 'number'
                ? point.lon
                : null;
            if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
              return;
            }
            const previous = ordered[ordered.length - 1];
            if (
              previous &&
              Math.abs(previous.lat - lat) < 1e-6 &&
              Math.abs(previous.lng - lng) < 1e-6
            ) {
              return;
            }
            ordered.push({
              hop: typeof point.hop === 'string' ? point.hop : '',
              direction: typeof point.direction === 'string' ? point.direction : '',
              lat,
              lng,
              label: typeof point.label === 'string' ? point.label : ''
            });
          });

          if (ordered.length < 2) {
            return [];
          }

          return ordered.map((entry, index) => ({
            ...entry,
            timestampMs: index * FALLBACK_SEGMENT_DURATION_MS
          }));
        }

        function normalizeHopLogEntry(entry) {
          if (!entry || typeof entry !== 'object') {
            return null;
          }
          const hop = sanitizeHopKey(typeof entry.hop === 'string' ? entry.hop : '');
          if (!hop || !HOP_COORDINATES[hop]) {
            return null;
          }
          const detail = HOP_COORDINATES[hop];
          let timestampMs = null;
          if (typeof entry.timestamp_ms === 'number' && Number.isFinite(entry.timestamp_ms)) {
            timestampMs = entry.timestamp_ms;
          } else if (typeof entry.timestamp === 'number' && Number.isFinite(entry.timestamp)) {
            timestampMs = entry.timestamp;
          } else if (typeof entry.timestamp === 'string') {
            const parsed = Date.parse(entry.timestamp);
            timestampMs = Number.isNaN(parsed) ? null : parsed;
          }
          return {
            hop,
            direction: typeof entry.direction === 'string' ? entry.direction : '',
            timestampMs: Number.isFinite(timestampMs) ? timestampMs : null,
            lat: detail.lat,
            lng: detail.lng,
            label: detail.label
          };
        }

        function updateMapWithHopLog(entries) {
          const normalized = [];
          if (Array.isArray(entries)) {
            entries.forEach((entry) => {
              const normalizedEntry = normalizeHopLogEntry(entry);
              if (normalizedEntry) {
                normalized.push(normalizedEntry);
              }
            });
          }
          syncMapWithPoints(normalized);
          return normalized;
        }

        function toRad(deg) {
          return (deg * Math.PI) / 180;
        }

        function toDeg(rad) {
          return (rad * 180) / Math.PI;
        }

        function interpolateGreatCircle(from, to, t) {
          const lonFrom = typeof from.lon === 'number' ? from.lon : from.lng;
          const lonTo = typeof to.lon === 'number' ? to.lon : to.lng;
          const lat1 = toRad(from.lat);
          const lon1 = toRad(lonFrom);
          const lat2 = toRad(to.lat);
          const lon2 = toRad(lonTo);

          const x1 = Math.cos(lat1) * Math.cos(lon1);
          const y1 = Math.cos(lat1) * Math.sin(lon1);
          const z1 = Math.sin(lat1);

          const x2 = Math.cos(lat2) * Math.cos(lon2);
          const y2 = Math.cos(lat2) * Math.sin(lon2);
          const z2 = Math.sin(lat2);

          let dot = x1 * x2 + y1 * y2 + z1 * z2;
          dot = Math.min(1, Math.max(-1, dot));
          const omega = Math.acos(dot);

          if (omega < 1e-6) {
            return { lat: from.lat, lon: lonFrom };
          }

          const sinOmega = Math.sin(omega);
          const t1 = Math.sin((1 - t) * omega) / sinOmega;
          const t2 = Math.sin(t * omega) / sinOmega;

          const x = t1 * x1 + t2 * x2;
          const y = t1 * y1 + t2 * y2;
          const z = t1 * z1 + t2 * z2;

          const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
          let lon = Math.atan2(y, x);

          let latDeg = toDeg(lat);
          let lonDeg = toDeg(lon);

          if (lonDeg < -180) lonDeg += 360;
          if (lonDeg > 180) lonDeg -= 360;

          return { lat: latDeg, lon: lonDeg };
        }

        function getOrbPoint(chart, fallbackPoint) {
          if (!chart) return null;
          let orbPoint = chart.get('orb-point');
          if (orbPoint) {
            return orbPoint;
          }
          const orbSeries = chart.get('orb-series');
          if (!orbSeries) return null;
          const start = fallbackPoint || DEFAULT_ORB_POSITION;
          if (!start) return null;
          const lonValue =
            typeof start.lon === 'number'
              ? start.lon
              : typeof start.lng === 'number'
              ? start.lng
              : null;
          if (!Number.isFinite(start.lat) || !Number.isFinite(lonValue)) {
            return null;
          }
          orbSeries.setData(
            [
              {
                id: 'orb-point',
                name: ORB_LABEL_PLAIN,
                lat: start.lat,
                lon: lonValue
              }
            ],
            false
          );
          chart.redraw();
          orbPoint = chart.get('orb-point');
          if (orbPoint) {
            lastKnownOrbPosition = { lat: start.lat, lon: lonValue };
          }
          return orbPoint;
        }

        function applyOrbPosition(orbPoint, position) {
          if (!orbPoint || !position) {
            return;
          }
          const lat = typeof position.lat === 'number' ? position.lat : null;
          const lon =
            typeof position.lon === 'number'
              ? position.lon
              : typeof position.lng === 'number'
              ? position.lng
              : null;
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
            return;
          }
          orbPoint.update({ lat, lon }, true, false);
          lastKnownOrbPosition = { lat, lon };
        }

        function hideOrbMarker() {
          mapState.animationToken += 1;
          if (mapState.animationFrame) {
            cancelAnimationFrame(mapState.animationFrame);
            mapState.animationFrame = null;
          }
          const fallback =
            lastKnownOrbPosition ||
            (DEFAULT_ORB_POSITION
              ? { lat: DEFAULT_ORB_POSITION.lat, lon: DEFAULT_ORB_POSITION.lng }
              : null);
          if (!fallback) {
            return;
          }
          void initMap().then((chart) => {
            if (!chart) return;
            const orbPoint = getOrbPoint(chart, fallback);
            if (orbPoint) {
              applyOrbPosition(orbPoint, fallback);
            }
          });
        }

        function buildAnimationSegmentsFromTimeline(timeline) {
          const segments = [];
          let totalDuration = 0;
          if (!Array.isArray(timeline) || timeline.length < 2) {
            return { segments, totalDuration };
          }
          for (let i = 1; i < timeline.length; i += 1) {
            const prev = timeline[i - 1];
            const current = timeline[i];
            if (!prev || !current) continue;
            const from = { lat: prev.lat, lon: prev.lng };
            const to = { lat: current.lat, lon: current.lng };
            if (!Number.isFinite(from.lat) || !Number.isFinite(from.lon)) continue;
            if (!Number.isFinite(to.lat) || !Number.isFinite(to.lon)) continue;
            const rawDuration = Number(current.timestampMs) - Number(prev.timestampMs);
            const duration = Number.isFinite(rawDuration) ? Math.max(0, rawDuration) : 0;
            const segment = {
              from,
              to,
              start: totalDuration,
              duration,
              end: totalDuration + duration
            };
            segments.push(segment);
            totalDuration += duration;
          }
          return { segments, totalDuration };
        }

        function startOrbAnimation(routePoints) {
          if (mapState.animationFrame) {
            cancelAnimationFrame(mapState.animationFrame);
            mapState.animationFrame = null;
          }
          if (!Array.isArray(routePoints) || routePoints.length === 0) {
            hideOrbMarker();
            return;
          }

          let timeline = buildTimestampTimeline(routePoints);
          if (timeline.length < 2) {
            timeline = buildFallbackTimeline(routePoints);
          }

          if (timeline.length < 2) {
            const finalPoint = timeline[0] || routePoints[routePoints.length - 1] || null;
            if (finalPoint) {
              void initMap().then((chart) => {
                if (!chart) return;
                const orbPoint = getOrbPoint(chart, finalPoint);
                if (orbPoint) {
                  applyOrbPosition(orbPoint, finalPoint);
                }
              });
            } else {
              hideOrbMarker();
            }
            return;
          }

          let { segments, totalDuration } = buildAnimationSegmentsFromTimeline(timeline);

          if (segments.length === 0 || totalDuration <= 0) {
            const fallbackTimeline = buildFallbackTimeline(routePoints);
            if (fallbackTimeline.length >= 2) {
              timeline = fallbackTimeline;
              ({ segments, totalDuration } = buildAnimationSegmentsFromTimeline(timeline));
            }
          }

          if (segments.length === 0 || totalDuration <= 0) {
            const finalPoint = timeline[timeline.length - 1];
            if (finalPoint) {
              void initMap().then((chart) => {
                if (!chart) return;
                const orbPoint = getOrbPoint(chart, finalPoint);
                if (orbPoint) {
                  applyOrbPosition(orbPoint, finalPoint);
                }
              });
            }
            return;
          }

          const animationToken = (mapState.animationToken += 1);

          void initMap().then((chart) => {
            if (!chart || mapState.animationToken !== animationToken) {
              return;
            }

            const orbPoint = getOrbPoint(chart, timeline[0]);
            if (!orbPoint) {
              return;
            }

            applyOrbPosition(orbPoint, timeline[0]);
            const animationStart = performance.now();

            const step = (timestamp) => {
              if (mapState.animationToken !== animationToken) {
                return;
              }

              const elapsed = timestamp - animationStart;
              if (elapsed >= totalDuration) {
                const finalSegment = segments[segments.length - 1];
                applyOrbPosition(orbPoint, finalSegment.to);
                mapState.animationFrame = null;
                return;
              }

              const current = segments.find((segment) => elapsed <= segment.end) || segments[segments.length - 1];
              const localTime = Math.max(0, Math.min(current.duration, elapsed - current.start));
              const progress = current.duration === 0 ? 1 : localTime / current.duration;
              const position = interpolateGreatCircle(current.from, current.to, progress);
              applyOrbPosition(orbPoint, position);
              mapState.animationFrame = requestAnimationFrame(step);
            };

            mapState.animationFrame = requestAnimationFrame(step);
          });
        }

        let running = false;
        let iteration = 0;
        let initialSeed = '';
        let lastAssistantText = '';
        const pendingUpdates = [];
        const FIRST_HOP_URL = 'https://muttr-us-east.azurewebsites.net/api/muttr';
        let currentEndpoint = FIRST_HOP_URL;

        const baseUpdateNote = updateNote ? updateNote.textContent.trim() : '';

        function refreshUpdateNote() {
          if (!updateNote) return;
          const count = pendingUpdates.length;
          if (count === 0) {
            updateNote.textContent = baseUpdateNote;
          } else if (count === 1) {
            updateNote.textContent = `${baseUpdateNote} (1 update queued)`;
          } else {
            updateNote.textContent = `${baseUpdateNote} (${count} updates queued)`;
          }
        }

        refreshUpdateNote();

        function pickSupportedMimeType() {
          if (typeof window === 'undefined' || typeof window.MediaRecorder === 'undefined') {
            return '';
          }
          if (typeof window.MediaRecorder.isTypeSupported !== 'function') {
            return '';
          }
          const candidates = ['audio/webm;codecs=opus', 'audio/ogg;codecs=opus', 'audio/webm'];
          return candidates.find((type) => window.MediaRecorder.isTypeSupported(type)) || '';
        }

        function shouldDisableAudioButton(button) {
          if (!button || !audioState.supported) {
            return true;
          }
          const target = button.dataset.audioTarget || '';
          if (target === 'seed') {
            return seed ? seed.readOnly : true;
          }
          return false;
        }

        function refreshAudioButtonDisabled(button) {
          if (!button) return;
          const locked = shouldDisableAudioButton(button);
          if (!button.classList.contains('is-processing')) {
            button.disabled = locked;
          } else {
            button.disabled = true;
          }
        }

        function setAudioButtonRecording(button, isRecording) {
          if (!button) return;
          const recording = Boolean(isRecording);
          button.classList.toggle('is-recording', recording);
          button.setAttribute('aria-pressed', recording ? 'true' : 'false');
          if (!recording && !button.classList.contains('is-processing')) {
            refreshAudioButtonDisabled(button);
          } else if (recording) {
            button.disabled = false;
          }
        }

        function setAudioButtonProcessing(button, isProcessing) {
          if (!button) return;
          const processing = Boolean(isProcessing);
          button.classList.toggle('is-processing', processing);
          if (processing) {
            button.disabled = true;
          } else {
            refreshAudioButtonDisabled(button);
          }
        }

        function stopActiveRecording() {
          if (audioState.mediaRecorder && audioState.mediaRecorder.state !== 'inactive') {
            try {
              audioState.mediaRecorder.stop();
            } catch (error) {
              console.error('Failed to stop recorder', error);
            }
          }
        }

        function resetAudioRecordingState() {
          if (audioState.stopTimer) {
            clearTimeout(audioState.stopTimer);
            audioState.stopTimer = null;
          }
          audioState.mediaRecorder = null;
          audioState.chunks = [];
          audioState.recordingButton = null;
          audioState.recordingTarget = null;
        }

        function cleanupAudioStream() {
          if (audioState.stream) {
            audioState.stream.getTracks().forEach((track) => {
              try {
                track.stop();
              } catch (error) {
                console.error('Failed to stop track', error);
              }
            });
            audioState.stream = null;
          }
        }

        async function ensureSharedAudioContext() {
          if (!audioState.supported || !AudioContextCtor) {
            throw new Error('Audio capture is not supported in this browser.');
          }
          if (!audioState.audioContext) {
            audioState.audioContext = new AudioContextCtor();
          }
          if (audioState.audioContext.state === 'suspended') {
            try {
              await audioState.audioContext.resume();
            } catch (error) {
              console.warn('Unable to resume audio context', error);
            }
          }
          return audioState.audioContext;
        }

        async function decodeBlobToAudioBuffer(blob) {
          const arrayBuffer = await blob.arrayBuffer();
          const ctx = await ensureSharedAudioContext();
          return await new Promise((resolve, reject) => {
            ctx.decodeAudioData(
              arrayBuffer.slice(0),
              (buffer) => resolve(buffer),
              (error) => reject(error || new Error('decodeAudioData failed'))
            );
          });
        }

        function interleaveChannels(buffers) {
          if (!buffers || buffers.length === 0) {
            return new Float32Array(0);
          }
          if (buffers.length === 1) {
            return buffers[0];
          }
          const length = buffers[0].length;
          const result = new Float32Array(length * buffers.length);
          for (let i = 0; i < length; i += 1) {
            for (let channel = 0; channel < buffers.length; channel += 1) {
              result[i * buffers.length + channel] = buffers[channel][i] || 0;
            }
          }
          return result;
        }

        function audioBufferToWav(audioBuffer) {
          const numChannels = audioBuffer.numberOfChannels || 1;
          const sampleRate = audioBuffer.sampleRate || 44100;
          const channelData = [];
          for (let i = 0; i < numChannels; i += 1) {
            channelData.push(audioBuffer.getChannelData(i));
          }
          const interleaved = interleaveChannels(channelData);
          const bytesPerSample = 2;
          const blockAlign = numChannels * bytesPerSample;
          const buffer = new ArrayBuffer(44 + interleaved.length * bytesPerSample);
          const view = new DataView(buffer);
          let offset = 0;

          function writeString(str) {
            for (let i = 0; i < str.length; i += 1) {
              view.setUint8(offset + i, str.charCodeAt(i));
            }
            offset += str.length;
          }

          function writeUint16(value) {
            view.setUint16(offset, value, true);
            offset += 2;
          }

          function writeUint32(value) {
            view.setUint32(offset, value, true);
            offset += 4;
          }

          writeString('RIFF');
          writeUint32(36 + interleaved.length * bytesPerSample);
          writeString('WAVE');
          writeString('fmt ');
          writeUint32(16);
          writeUint16(1);
          writeUint16(numChannels);
          writeUint32(sampleRate);
          writeUint32(sampleRate * blockAlign);
          writeUint16(blockAlign);
          writeUint16(8 * bytesPerSample);
          writeString('data');
          writeUint32(interleaved.length * bytesPerSample);

          let dataOffset = 44;
          for (let i = 0; i < interleaved.length; i += 1) {
            const sample = Math.max(-1, Math.min(1, interleaved[i]));
            const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7fff;
            view.setInt16(dataOffset, intSample, true);
            dataOffset += 2;
          }

          return buffer;
        }

        function arrayBufferToBase64(buffer) {
          let binary = '';
          const bytes = new Uint8Array(buffer);
          const chunkSize = 0x8000;
          for (let i = 0; i < bytes.length; i += chunkSize) {
            const chunk = bytes.subarray(i, i + chunkSize);
            binary += String.fromCharCode.apply(null, chunk);
          }
          return btoa(binary);
        }

        async function convertBlobToWavBase64(blob) {
          const audioBuffer = await decodeBlobToAudioBuffer(blob);
          const wavBuffer = audioBufferToWav(audioBuffer);
          return { base64: arrayBufferToBase64(wavBuffer), format: 'wav' };
        }

        async function sendAudioForTranscription(base64, format, target) {
          const prompt =
            target === 'update'
              ? 'Transcribe this todo list update exactly as spoken. Return only the transcript.'
              : 'Transcribe this todo list seed exactly as spoken, keeping its natural structure. Return only the transcript.';
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 45000);
          try {
            const response = await fetch(AUDIO_TRANSCRIBE_ENDPOINT, {
              method: 'POST',
              headers: {
                'content-type': 'application/json'
              },
              body: JSON.stringify({
                audio: { data: base64, format },
                target,
                prompt
              }),
              signal: controller.signal,
              mode: 'cors',
              credentials: 'omit'
            });
            const responseText = await response.text();
            let payload = null;
            try {
              payload = JSON.parse(responseText);
            } catch (error) {
              if (response.ok) {
                throw new Error('Audio transcription returned an unexpected response.');
              }
              throw new Error(responseText || 'Audio transcription failed.');
            }

            if (!response.ok) {
              const message = payload && payload.error ? payload.error : 'Audio transcription failed.';
              throw new Error(message);
            }

            if (!payload || typeof payload.text !== 'string' || !payload.text.trim()) {
              throw new Error('Audio transcription returned an empty result.');
            }

            return payload.text.trim();
          } catch (error) {
            if (error.name === 'AbortError') {
              throw new Error('Audio transcription timed out. Please try again.');
            }
            throw error;
          } finally {
            clearTimeout(timeout);
          }
        }

        function applyTranscriptToInputs(target, transcript) {
          const cleaned = typeof transcript === 'string' ? transcript.trim() : '';
          if (!cleaned) {
            return;
          }
          if (target === 'update' && updateInput) {
            updateInput.value = cleaned;
            updateInput.dispatchEvent(new Event('input', { bubbles: true }));
            updateInput.focus();
            return;
          }
          if (seed) {
            const existing = seed.value || '';
            const needsBreak = existing && !existing.endsWith('\n') ? '\n' : '';
            seed.value = existing ? `${existing}${needsBreak}${cleaned}` : cleaned;
            seed.dispatchEvent(new Event('input', { bubbles: true }));
            seed.focus();
          }
        }

        async function finalizeRecording(chunks, target, button, mimeType) {
          cleanupAudioStream();
          resetAudioRecordingState();
          if (!chunks || chunks.length === 0) {
            refreshAudioButtonDisabled(button);
            return;
          }
          setAudioButtonProcessing(button, true);
          try {
            const blob = new Blob(chunks, { type: mimeType || 'audio/webm' });
            const { base64, format } = await convertBlobToWavBase64(blob);
            const transcript = await sendAudioForTranscription(base64, format, target);
            applyTranscriptToInputs(target, transcript);
            showError('');
          } catch (error) {
            console.error(error);
            showError(error.message || 'Failed to transcribe audio. Please try again.');
          } finally {
            setAudioButtonProcessing(button, false);
            refreshAudioButtonDisabled(button);
          }
        }

        async function startRecording(button) {
          if (!audioState.supported) {
            showError('Audio capture is not supported in this browser.');
            return;
          }
          if (!button) {
            return;
          }
          const target = button.dataset.audioTarget || 'seed';
          const mimeType = pickSupportedMimeType();
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const recorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);
            audioState.stream = stream;
            audioState.mediaRecorder = recorder;
            audioState.chunks = [];
            audioState.recordingButton = button;
            audioState.recordingTarget = target;
            setAudioButtonRecording(button, true);
            recorder.addEventListener('dataavailable', (event) => {
              if (event.data && event.data.size > 0) {
                audioState.chunks.push(event.data);
              }
            });
            recorder.addEventListener('stop', () => {
              const chunksCopy = audioState.chunks.slice();
              const targetCopy = audioState.recordingTarget;
              const buttonCopy = audioState.recordingButton;
              if (audioState.stopTimer) {
                clearTimeout(audioState.stopTimer);
                audioState.stopTimer = null;
              }
              setAudioButtonRecording(buttonCopy, false);
              finalizeRecording(chunksCopy, targetCopy, buttonCopy, recorder.mimeType);
            });
            recorder.addEventListener('error', (event) => {
              console.error(event.error || event);
              showError('Recording error. Please try again.');
              setAudioButtonRecording(button, false);
              cleanupAudioStream();
              resetAudioRecordingState();
            });
            recorder.start();
            audioState.stopTimer = setTimeout(() => {
              if (recorder.state === 'recording') {
                recorder.stop();
              }
            }, AUDIO_MAX_RECORDING_MS);
          } catch (error) {
            console.error(error);
            showError('Unable to access your microphone. Please allow permissions and try again.');
            cleanupAudioStream();
            resetAudioRecordingState();
          }
        }

        function handleAudioButtonPress(button) {
          if (!audioState.supported || !button || button.classList.contains('is-processing')) {
            return;
          }
          if (audioState.mediaRecorder && audioState.mediaRecorder.state === 'recording') {
            stopActiveRecording();
            return;
          }
          startRecording(button);
        }

        function initAudioButtons() {
          if (!audioButtons || audioButtons.length === 0) {
            return;
          }
          if (!audioState.supported) {
            audioButtons.forEach((button) => {
              if (!button) return;
              button.disabled = true;
              button.title = 'Audio capture is not supported in this browser.';
            });
            return;
          }
          audioButtons.forEach((button) => {
            if (!button) return;
            button.setAttribute('aria-pressed', 'false');
            refreshAudioButtonDisabled(button);
            button.addEventListener('click', () => handleAudioButtonPress(button));
          });
        }

        initMap();
        initAudioButtons();

        function setSeedEditable(isEditable) {
          if (!seed) return;
          seed.readOnly = !isEditable;
          seed.classList.toggle('relay-seed--locked', !isEditable);
          if (!isEditable && audioState.recordingTarget === 'seed') {
            stopActiveRecording();
          }
          refreshAudioButtonDisabled(seedAudioButton);
        }

        setSeedEditable(true);
        renderHopTable();

        function queueUpdate(text) {
          const trimmed = typeof text === 'string' ? text.trim() : '';
          if (!trimmed) {
            return;
          }
          pendingUpdates.push(trimmed);
          if (updateInput) {
            updateInput.value = '';
            updateInput.focus();
          }
          refreshUpdateNote();
        }

        function setStatus(text) {
          statusEl.textContent = text;
        }

        function showError(message) {
          if (message) {
            errorEl.hidden = false;
            errorEl.textContent = message;
          } else {
            errorEl.hidden = true;
            errorEl.textContent = '';
          }
        }

        const durationNumberFormatter = new Intl.NumberFormat(undefined, {
          maximumFractionDigits: 0
        });

        function formatDuration(durationMs) {
          if (!Number.isFinite(durationMs)) {
            return '—';
          }
          return `${durationNumberFormatter.format(Math.round(durationMs))} ms`;
        }

        function deriveDurationMs(entry, prevEntry) {
          if (entry && typeof entry.duration_ms === 'number') {
            return entry.duration_ms;
          }
          if (entry && typeof entry.delay_ms === 'number' && entry.delay_ms > 0) {
            return entry.delay_ms;
          }
          const currentTimestamp =
            entry && typeof entry.timestamp_ms === 'number'
              ? entry.timestamp_ms
              : entry && typeof entry.timestamp === 'number'
              ? entry.timestamp
              : entry && typeof entry.timestamp === 'string'
              ? Date.parse(entry.timestamp)
              : NaN;
          const prevTimestamp =
            prevEntry && typeof prevEntry.timestamp_ms === 'number'
              ? prevEntry.timestamp_ms
              : prevEntry && typeof prevEntry.timestamp === 'number'
              ? prevEntry.timestamp
              : prevEntry && typeof prevEntry.timestamp === 'string'
              ? Date.parse(prevEntry.timestamp)
              : NaN;
          if (!Number.isFinite(currentTimestamp) || !Number.isFinite(prevTimestamp)) {
            return null;
          }
          const delta = currentTimestamp - prevTimestamp;
          return Number.isFinite(delta) && delta >= 0 ? delta : null;
        }

        function buildHopTableKey(entry) {
          if (!entry || typeof entry !== 'object') {
            return null;
          }
          const hopValue = typeof entry.hop === 'string' ? entry.hop : '';
          const directionValue = typeof entry.direction === 'string' ? entry.direction : '';
          const pathValue = typeof entry.path === 'string' ? entry.path : '';
          const timestampValue =
            typeof entry.timestamp === 'string'
              ? entry.timestamp
              : typeof entry.timestamp === 'number'
              ? entry.timestamp
              : typeof entry.timestamp_ms === 'number'
              ? entry.timestamp_ms
              : '';
          return [hopValue, directionValue, pathValue, timestampValue].join('|');
        }

        function renderHopTable() {
          if (!hopTableBody) return;
          hopTableBody.innerHTML = '';
          if (hopTableHistory.length === 0) {
            const emptyRow = document.createElement('tr');
            const cell = document.createElement('td');
            cell.colSpan = 4;
            cell.textContent = 'Awaiting the first hop.';
            emptyRow.appendChild(cell);
            hopTableBody.appendChild(emptyRow);
            return;
          }

          hopTableHistory.forEach((entry) => {
            const row = document.createElement('tr');

            const hopCell = document.createElement('td');
            hopCell.textContent = describeHop(entry);
            row.appendChild(hopCell);

            const directionCell = document.createElement('td');
            directionCell.textContent = entry && entry.direction ? entry.direction : '—';
            row.appendChild(directionCell);

            const durationCell = document.createElement('td');
            const durationValue = entry && typeof entry.duration_ms === 'number' ? entry.duration_ms : null;
            durationCell.textContent = formatDuration(durationValue);
            row.appendChild(durationCell);

            const timestampCell = document.createElement('td');
            const timestampValue =
              entry && Object.prototype.hasOwnProperty.call(entry, 'timestamp')
                ? entry.timestamp
                : entry && typeof entry.timestamp_ms === 'number'
                ? entry.timestamp_ms
                : null;
            timestampCell.textContent = formatTimestamp(timestampValue);
            row.appendChild(timestampCell);

            hopTableBody.appendChild(row);
          });
        }

        function appendHopTableEntries(entries) {
          if (!Array.isArray(entries) || entries.length === 0) {
            renderHopTable();
            return;
          }

          entries.forEach((entry, index) => {
            const key = buildHopTableKey(entry);
            if (!key || hopTableKeySet.has(key)) {
              return;
            }
            const prevEntry = index > 0 ? entries[index - 1] : null;
            const derivedDuration = deriveDurationMs(entry, prevEntry);
            const storedEntry = {
              ...entry,
              duration_ms: Number.isFinite(derivedDuration) ? derivedDuration : null,
              hopTableKey: key
            };
            hopTableHistory.unshift(storedEntry);
            hopTableKeySet.add(key);
          });

          while (hopTableHistory.length > HOP_TABLE_HISTORY_LIMIT) {
            const removed = hopTableHistory.pop();
            if (removed && removed.hopTableKey) {
              hopTableKeySet.delete(removed.hopTableKey);
            }
          }

          renderHopTable();
        }

        function resetHopTableHistory() {
          hopTableHistory.length = 0;
          hopTableKeySet.clear();
          renderHopTable();
        }

        function formatTimestamp(value) {
          if (value === null || value === undefined) return '—';
          const ms =
            typeof value === 'number' && Number.isFinite(value)
              ? value
              : Date.parse(value);
          if (Number.isNaN(ms)) {
            return '—';
          }
          return new Date(ms).toLocaleString(undefined, {
            hour12: false,
            month: 'short',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          });
        }

        function describeHop(entry) {
          if (!entry) {
            return '—';
          }
          const hopKey = sanitizeHopKey(typeof entry.hop === 'string' ? entry.hop : '');
          const detail = hopKey ? HOP_COORDINATES[hopKey] : null;
          if (detail) {
            return detail.label;
          }
          if (hopKey) {
            return hopKey;
          }
          if (entry.raw) {
            return entry.raw;
          }
          return '—';
        }

        function updateHopTable(entries) {
          appendHopTableEntries(entries);
        }

        function updateUI(result) {
          if (!result) return [];
          lastAssistantText = typeof result.assistant_text === 'string' ? result.assistant_text : '';
          if (seed) {
            const displayText = lastAssistantText || '(no assistant response yet)';
            seed.value = displayText;
          }
          const hops = Array.isArray(result.hop_log) ? result.hop_log : [];
          updateHopTable(hops);
          return updateMapWithHopLog(hops);
        }

        function buildRequestPayload() {
          const primaryUserMessage =
            iteration === 0
              ? initialSeed || '(empty seed)'
              : lastAssistantText || '(previous assistant output unavailable)';

          const queued = pendingUpdates.splice(0, pendingUpdates.length);
          const messages = [{ role: 'user', content: primaryUserMessage }];

          queued.forEach((content) => {
            messages.push({ role: 'user', content });
          });

          refreshUpdateNote();

          return JSON.stringify({
            version: 1,
            messages,
            metadata: {
              origin: 'muttr-ui',
              iteration,
              queued_updates: queued.length
            }
          });
        }

        async function runOnce(payload) {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 60000);
          try {
            const response = await fetch(currentEndpoint, {
              method: 'POST',
              headers: {
                'content-type': 'application/json; charset=utf-8',
                'X-Direction': 'forward'
              },
              body: payload,
              signal: controller.signal,
              mode: 'cors',
              credentials: 'omit'
            });

            if (!response.ok) {
              const text = await response.text();
              throw new Error(`Hop failed: ${response.status} ${text}`);
            }

            const result = await response.json();
            return result;
          } catch (error) {
            throw error;
          } finally {
            clearTimeout(timeout);
          }
        }

        async function loop() {
          if (!running) return;
          setStatus('in-flight');
          try {
            const payload = buildRequestPayload();
            const result = await runOnce(payload);
            iteration += 1;
            iterationsEl.textContent = iteration;
            const routePoints = updateUI(result);
            showError('');
            if (!running) return;
            setStatus('waiting');
            startOrbAnimation(routePoints);
            requestAnimationFrame(loop);
          } catch (error) {
            console.error(error);
            setStatus('error');
            showError(error.message || 'Unknown error while calling the hop endpoint.');
            startBtn.disabled = false;
            stopBtn.disabled = true;
            setSeedEditable(true);
            running = false;
          }
        }

        if (updateForm) {
          updateForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!updateInput) return;
            queueUpdate(updateInput.value);
          });
        }

        suggestionButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const suggestion = button.dataset.suggestion || button.textContent || '';
            queueUpdate(suggestion);
          });
        });

        startBtn.addEventListener('click', () => {
          if (running) return;
          running = true;
          iteration = 0;
          initialSeed = seed.value.trim() || '(empty seed)';
          lastAssistantText = '';
          iterationsEl.textContent = '0';
          startBtn.disabled = true;
          stopBtn.disabled = false;
          showError('');
          setStatus('booting');
          setSeedEditable(false);
          resetHopTableHistory();
          if (mapState.animationFrame) {
            cancelAnimationFrame(mapState.animationFrame);
            mapState.animationFrame = null;
          }
          hideOrbMarker();
          loop();
        });

        stopBtn.addEventListener('click', () => {
          running = false;
          startBtn.disabled = false;
          stopBtn.disabled = true;
          setStatus('stopped');
          setSeedEditable(true);
          if (mapState.animationFrame) {
            cancelAnimationFrame(mapState.animationFrame);
            mapState.animationFrame = null;
          }
          hideOrbMarker();
        });
      })();
    </script>
  </body>
</html>
