<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>muttr · global todo telephone</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-o9N1j7kCpk//4cw3AV2uy1S8MaqkOawx2UY8ailqXFw="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-XQoYMqMTK8LvdlDXvxdgZGH5f9s74pNgMDwWv6f5pFg="
      crossorigin=""
    ></script>
    <style>
      :root {
        color-scheme: dark light;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: radial-gradient(circle at top left, #1f2937, #111827 50%, #0b1120);
        color: #f9fafb;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr auto;
        padding: 1.5rem;
        gap: 1.5rem;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.8rem, 3vw, 2.6rem);
      }

      main {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        align-items: start;
      }

      section {
        background: rgba(15, 23, 42, 0.72);
        border: 1px solid rgba(148, 163, 184, 0.18);
        border-radius: 16px;
        padding: 1.25rem;
        box-shadow: 0 25px 45px rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(16px);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      textarea {
        min-height: 240px;
        resize: vertical;
        width: 100%;
        padding: 0.75rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.6);
        color: inherit;
        font-size: 0.95rem;
        line-height: 1.5;
        font-family: "Iosevka", "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
      }

      textarea.compact {
        min-height: 120px;
      }

      .text-input {
        width: 100%;
        padding: 0.75rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.6);
        color: inherit;
        font-size: 0.95rem;
        line-height: 1.4;
        font-family: "Iosevka", "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
      }

      .suggestion-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.25rem;
      }

      .suggestion-buttons button {
        white-space: nowrap;
      }

      button {
        appearance: none;
        border: none;
        border-radius: 999px;
        padding: 0.75rem 1.5rem;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
        background: linear-gradient(120deg, #f97316, #ec4899);
        color: white;
        box-shadow: 0 18px 30px rgba(236, 72, 153, 0.35);
      }

      button:hover:not([disabled]) {
        transform: translateY(-1px);
        box-shadow: 0 20px 40px rgba(236, 72, 153, 0.45);
      }

      button.secondary-button {
        background: rgba(15, 23, 42, 0.55);
        color: #f97316;
        border: 1px solid rgba(249, 115, 22, 0.4);
        box-shadow: none;
        padding: 0.6rem 1.1rem;
      }

      button.secondary-button:hover:not([disabled]) {
        box-shadow: 0 12px 22px rgba(249, 115, 22, 0.25);
      }

      button[disabled] {
        cursor: progress;
        opacity: 0.65;
        box-shadow: none;
      }

      .controls {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.35rem 0.75rem;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        font-size: 0.8rem;
        background: rgba(15, 23, 42, 0.55);
      }

      .notice {
        font-size: 0.8rem;
        opacity: 0.75;
        margin: 0;
      }

      label {
        font-size: 0.85rem;
        font-weight: 600;
        letter-spacing: 0.01em;
      }

      .dev-note {
        font-size: 0.75rem;
        opacity: 0.65;
        margin: 0;
      }

      .error-message {
        margin: 0;
        font-size: 0.85rem;
        color: #fca5a5;
      }

      pre {
        margin: 0;
        overflow: auto;
        font-size: 0.85rem;
        line-height: 1.5;
        background: rgba(15, 23, 42, 0.6);
        border-radius: 12px;
        padding: 0.75rem;
        max-height: 360px;
      }

      .log-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-height: 320px;
        overflow: auto;
      }

      .log-item {
        font-family: "Iosevka", "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
        font-size: 0.8rem;
        white-space: pre-wrap;
        word-break: break-word;
        background: rgba(15, 23, 42, 0.55);
        border-radius: 12px;
        padding: 0.65rem;
      }

      #map {
        width: 100%;
        min-height: 320px;
        height: clamp(320px, 35vw, 500px);
        border-radius: 16px;
        overflow: hidden;
        border: 1px solid rgba(148, 163, 184, 0.18);
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.35);
      }

      .leaflet-container {
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: rgba(15, 23, 42, 0.85);
      }

      .map-orb {
        width: 18px;
        height: 18px;
        border-radius: 999px;
        background: radial-gradient(circle at center, rgba(251, 113, 133, 0.95) 0%, rgba(249, 115, 22, 0.85) 45%, rgba(15, 23, 42, 0) 70%);
        box-shadow: 0 0 18px rgba(249, 115, 22, 0.8), 0 0 32px rgba(236, 72, 153, 0.65);
      }

      footer {
        opacity: 0.6;
        font-size: 0.75rem;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>muttr: the borderless todo telephone</h1>
      <p>Everything you type goes on a global sightseeing tour through a daisy-chained LLM relay.</p>
    </header>

    <main>
      <section>
        <h2>Place your concerns here</h2>
        <textarea id="seed" placeholder="List the burdens weighing you down...">- Buy groceries
- Eat lunch
- Mow grass
- Do Taxes</textarea>
        <label for="update-input">Update your list</label>
        <form id="update-form" class="stack">
          <input
            id="update-input"
            class="text-input"
            type="text"
            placeholder="Share what changed since the last lap"
            autocomplete="off"
          />
          <div class="controls">
            <button type="submit" class="secondary-button">Submit update</button>
          </div>
        </form>
        <div class="suggestion-buttons">
          <button type="button" class="secondary-button suggestion-button" data-suggestion="I completed the first item">
            I completed the first item
          </button>
          <button type="button" class="secondary-button suggestion-button" data-suggestion="And my cat needs to be spayed.">
            And my cat needs to be spayed.
          </button>
          <button type="button" class="secondary-button suggestion-button" data-suggestion="Time is closing in on me">
            Time is closing in on me
          </button>
        </div>
        <p class="dev-note" id="update-note">
          Submitted updates are queued and will join the next hop in the circuit.
        </p>
        <p class="notice">
          The loop always launches through the public muttr entry hop. Bring your own client if you need a private circuit.
        </p>
        <p id="error" class="error-message" hidden></p>
        <div class="controls">
          <button id="start">Start Global Loop</button>
          <button id="stop" disabled>Stop</button>
          <span class="badge">iteration: <span id="iterations">0</span></span>
          <span class="badge">status: <span id="status">idle</span></span>
        </div>
      </section>

      <section>
        <h2>Assistant whisper</h2>
        <pre id="assistant">(no assistant response yet)</pre>
      </section>

      <section>
        <h2>Hop chain</h2>
        <pre id="chain">(awaiting first run)</pre>
        <h3>Hop log</h3>
        <ul id="log" class="log-list"></ul>
      </section>

      <section>
        <h2>Global hop map</h2>
        <p class="dev-note">Each leg renders using the latest round trip timestamps. Watch the orb trace the last lap in real time.</p>
        <div id="map" role="img" aria-label="World map showing the muttr hop path"></div>
      </section>

      <section>
        <h2>Raw OpenRouter JSON</h2>
        <pre id="raw">(awaiting data)</pre>
      </section>
    </main>

    <footer>
      <p>There is no storage. Only vibes. Powered by Azure Functions + OpenRouter.</p>
    </footer>

    <script>
      const seed = document.querySelector('#seed');
      const updateForm = document.querySelector('#update-form');
      const updateInput = document.querySelector('#update-input');
      const suggestionButtons = document.querySelectorAll('.suggestion-button');
      const updateNote = document.querySelector('#update-note');
      const startBtn = document.querySelector('#start');
      const stopBtn = document.querySelector('#stop');
      const iterationsEl = document.querySelector('#iterations');
      const statusEl = document.querySelector('#status');
      const assistantEl = document.querySelector('#assistant');
      const chainEl = document.querySelector('#chain');
      const logEl = document.querySelector('#log');
      const rawEl = document.querySelector('#raw');
      const errorEl = document.querySelector('#error');
      const mapEl = document.querySelector('#map');

      const HOP_COORDINATES = {
        'muttr-us-east': { label: 'US East · Virginia, USA', lat: 37.505, lng: -77.320 },
        'muttr-brazil': { label: 'Brazil · São Paulo', lat: -23.5505, lng: -46.6333 },
        'muttr-uk': { label: 'United Kingdom · London', lat: 51.5072, lng: -0.1276 },
        'muttr-singapore': { label: 'Singapore', lat: 1.3521, lng: 103.8198 },
        'muttr-sydney': { label: 'Australia · Sydney', lat: -33.8688, lng: 151.2093 }
      };

      const mapState = {
        map: null,
        markers: new Map(),
        routeLine: null,
        orbMarker: null,
        animationFrame: null,
        hasFitBounds: false
      };

      function initMap() {
        if (!mapEl || typeof L === 'undefined') {
          return null;
        }
        if (mapState.map) {
          return mapState.map;
        }

        mapState.map = L.map(mapEl, {
          worldCopyJump: true,
          attributionControl: false,
          zoomControl: false
        }).setView([15, 0], 2);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 7,
          subdomains: 'abcd'
        }).addTo(mapState.map);

        L.control.zoom({ position: 'bottomright' }).addTo(mapState.map);
        ensureHopMarkers();
        setTimeout(() => {
          mapState.map.invalidateSize();
        }, 200);
        return mapState.map;
      }

      function ensureHopMarkers() {
        if (!mapState.map) return;
        Object.entries(HOP_COORDINATES).forEach(([key, detail]) => {
          if (mapState.markers.has(key)) return;
          const marker = L.circleMarker([detail.lat, detail.lng], {
            radius: 6,
            color: '#94a3b8',
            weight: 1.2,
            fillColor: '#94a3b8',
            fillOpacity: 0.3,
            opacity: 0.8
          }).addTo(mapState.map);
          marker.bindTooltip(`${detail.label}\n${key}`, { sticky: true });
          mapState.markers.set(key, marker);
        });
      }

      function normalizeHopLogEntry(entry) {
        if (!entry || typeof entry !== 'object') {
          return null;
        }
        const hop = typeof entry.hop === 'string' ? entry.hop.trim() : '';
        if (!hop || !HOP_COORDINATES[hop]) {
          return null;
        }
        const detail = HOP_COORDINATES[hop];
        const timestampMs = Date.parse(entry.timestamp);
        return {
          hop,
          direction: typeof entry.direction === 'string' ? entry.direction : '',
          timestamp: Number.isNaN(timestampMs) ? null : timestampMs,
          lat: detail.lat,
          lng: detail.lng,
          label: detail.label
        };
      }

      function updateMapWithHopLog(entries) {
        const map = initMap();
        if (!map) {
          return [];
        }

        const normalized = [];
        if (Array.isArray(entries)) {
          entries.forEach((entry) => {
            const normalizedEntry = normalizeHopLogEntry(entry);
            if (normalizedEntry) {
              normalized.push(normalizedEntry);
            }
          });
        }

        const latLngs = normalized.map((point) => [point.lat, point.lng]);

        if (latLngs.length > 0) {
          if (!mapState.routeLine) {
            mapState.routeLine = L.polyline(latLngs, {
              color: '#38bdf8',
              weight: 3,
              opacity: 0.7,
              dashArray: '10 8'
            }).addTo(map);
          } else {
            mapState.routeLine.setLatLngs(latLngs);
          }

          if (!mapState.hasFitBounds && latLngs.length >= 2) {
            map.fitBounds(L.latLngBounds(latLngs).pad(0.3));
            mapState.hasFitBounds = true;
          }
        } else if (mapState.routeLine) {
          mapState.routeLine.setLatLngs([]);
        }

        mapState.markers.forEach((marker) => {
          marker.setStyle({
            color: '#94a3b8',
            fillColor: '#94a3b8',
            fillOpacity: 0.3
          });
        });

        normalized.forEach((point) => {
          const marker = mapState.markers.get(point.hop);
          if (marker) {
            marker.setStyle({
              color: '#f97316',
              fillColor: '#f97316',
              fillOpacity: 0.85
            });
          }
        });

        return normalized;
      }

      function ensureOrbMarker(point) {
        const map = initMap();
        if (!map || !point) {
          return null;
        }

        if (!mapState.orbMarker) {
          const orbIcon = L.divIcon({ className: 'map-orb', iconSize: [18, 18] });
          mapState.orbMarker = L.marker([point.lat, point.lng], {
            icon: orbIcon,
            interactive: false
          }).addTo(map);
        } else {
          mapState.orbMarker.setLatLng([point.lat, point.lng]);
          if (!map.hasLayer(mapState.orbMarker)) {
            mapState.orbMarker.addTo(map);
          }
        }

        mapState.orbMarker.setOpacity(1);
        return mapState.orbMarker;
      }

      function hideOrbMarker() {
        if (mapState.orbMarker) {
          mapState.orbMarker.setOpacity(0);
        }
      }

      function startOrbAnimation(routePoints) {
        if (mapState.animationFrame) {
          cancelAnimationFrame(mapState.animationFrame);
          mapState.animationFrame = null;
        }

        const map = initMap();
        if (!map || !Array.isArray(routePoints) || routePoints.length === 0) {
          hideOrbMarker();
          return;
        }

        if (routePoints.length === 1) {
          ensureOrbMarker(routePoints[0]);
          return;
        }

        const timeline = routePoints.filter((point) => Number.isFinite(point.timestamp));

        if (timeline.length < 2) {
          ensureOrbMarker(routePoints[routePoints.length - 1]);
          return;
        }

        const segments = [];
        let cumulative = 0;
        for (let i = 1; i < timeline.length; i += 1) {
          const prev = timeline[i - 1];
          const current = timeline[i];
          const duration = Math.max(current.timestamp - prev.timestamp, 1);
          segments.push({
            from: prev,
            to: current,
            start: cumulative,
            duration,
            end: cumulative + duration
          });
          cumulative += duration;
        }

        if (segments.length === 0) {
          ensureOrbMarker(timeline[timeline.length - 1]);
          return;
        }

        const orb = ensureOrbMarker(timeline[0]);
        if (!orb) return;

        const totalDuration = segments[segments.length - 1].end;
        const animationStart = performance.now();

        function step() {
          const elapsed = performance.now() - animationStart;
          if (elapsed >= totalDuration) {
            const lastPoint = segments[segments.length - 1].to;
            orb.setLatLng([lastPoint.lat, lastPoint.lng]);
            mapState.animationFrame = null;
            return;
          }

          const currentTime = elapsed;
          let active = segments[0];
          for (let i = 0; i < segments.length; i += 1) {
            if (currentTime <= segments[i].end) {
              active = segments[i];
              break;
            }
          }

          const progress = active.duration <= 0 ? 1 : (currentTime - active.start) / active.duration;
          const clamped = Math.max(0, Math.min(1, progress));
          const lat = active.from.lat + (active.to.lat - active.from.lat) * clamped;
          const lng = active.from.lng + (active.to.lng - active.from.lng) * clamped;
          orb.setLatLng([lat, lng]);
          mapState.animationFrame = requestAnimationFrame(step);
        }

        mapState.animationFrame = requestAnimationFrame(step);
      }

      let running = false;
      let iteration = 0;
      let initialSeed = '';
      let lastAssistantText = '';
      const pendingUpdates = [];
      const FIRST_HOP_URL = 'https://muttr-us-east.azurewebsites.net/api/muttr';
      let currentEndpoint = FIRST_HOP_URL;

      const baseUpdateNote = updateNote ? updateNote.textContent.trim() : '';

      function refreshUpdateNote() {
        if (!updateNote) return;
        const count = pendingUpdates.length;
        if (count === 0) {
          updateNote.textContent = baseUpdateNote;
        } else if (count === 1) {
          updateNote.textContent = `${baseUpdateNote} (1 update queued)`;
        } else {
          updateNote.textContent = `${baseUpdateNote} (${count} updates queued)`;
        }
      }

      refreshUpdateNote();

      initMap();

      function queueUpdate(text) {
        const trimmed = typeof text === 'string' ? text.trim() : '';
        if (!trimmed) {
          return;
        }
        pendingUpdates.push(trimmed);
        if (updateInput) {
          updateInput.value = '';
          updateInput.focus();
        }
        refreshUpdateNote();
      }

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function showError(message) {
        if (message) {
          errorEl.hidden = false;
          errorEl.textContent = message;
        } else {
          errorEl.hidden = true;
          errorEl.textContent = '';
        }
      }

      function updateUI(result) {
        if (!result) return [];
        assistantEl.textContent = result.assistant_text || '(no assistant text)';
        chainEl.textContent = result.hop_chain || '(no chain)';
        rawEl.textContent = result.openrouter_response
          ? JSON.stringify(result.openrouter_response, null, 2)
          : '(no raw payload)';

        logEl.innerHTML = '';
        (result.hop_log || []).forEach((entry) => {
          const li = document.createElement('li');
          li.className = 'log-item';
          li.textContent = JSON.stringify(entry, null, 2);
          logEl.appendChild(li);
        });

        return updateMapWithHopLog(result.hop_log || []);
      }

      function buildRequestPayload() {
        const primaryUserMessage =
          iteration === 0
            ? initialSeed
            : lastAssistantText || '(previous assistant output unavailable)';

        const queued = pendingUpdates.splice(0, pendingUpdates.length);
        const messages = [{ role: 'user', content: primaryUserMessage }];

        queued.forEach((content) => {
          messages.push({ role: 'user', content });
        });

        refreshUpdateNote();

        return JSON.stringify({
          version: 1,
          messages,
          metadata: {
            origin: 'muttr-ui',
            iteration,
            queued_updates: queued.length
          }
        });
      }

      async function runOnce(payload) {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 60000);
        try {
          const response = await fetch(currentEndpoint, {
            method: 'POST',
            headers: {
              'content-type': 'application/json; charset=utf-8',
              'X-Direction': 'forward'
            },
            body: payload,
            signal: controller.signal,
            mode: 'cors',
            credentials: 'omit'
          });

          if (!response.ok) {
            const text = await response.text();
            throw new Error(`Hop failed: ${response.status} ${text}`);
          }

          const result = await response.json();
          return result;
        } catch (error) {
          throw error;
        } finally {
          clearTimeout(timeout);
        }
      }

      async function loop() {
        if (!running) return;
        setStatus('in-flight');
        try {
          const payload = buildRequestPayload();
          const result = await runOnce(payload);
          iteration += 1;
          iterationsEl.textContent = iteration;
          lastAssistantText = result && result.assistant_text ? result.assistant_text : '';
          const routePoints = updateUI(result);
          showError('');
          if (!running) return;
          setStatus('waiting');
          startOrbAnimation(routePoints);
          requestAnimationFrame(loop);
        } catch (error) {
          console.error(error);
          setStatus('error');
          showError(error.message || 'Unknown error while calling the hop endpoint.');
          startBtn.disabled = false;
          stopBtn.disabled = true;
          running = false;
        }
      }

      if (updateForm) {
        updateForm.addEventListener('submit', (event) => {
          event.preventDefault();
          if (!updateInput) return;
          queueUpdate(updateInput.value);
        });
      }

      suggestionButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const suggestion = button.dataset.suggestion || button.textContent || '';
          queueUpdate(suggestion);
        });
      });

      startBtn.addEventListener('click', () => {
        if (running) return;
        running = true;
        iteration = 0;
        initialSeed = seed.value.trim() || '(empty seed)';
        lastAssistantText = '';
        iterationsEl.textContent = '0';
        startBtn.disabled = true;
        stopBtn.disabled = false;
        showError('');
        setStatus('booting');
        if (mapState.animationFrame) {
          cancelAnimationFrame(mapState.animationFrame);
          mapState.animationFrame = null;
        }
        hideOrbMarker();
        loop();
      });

      stopBtn.addEventListener('click', () => {
        running = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus('stopped');
        if (mapState.animationFrame) {
          cancelAnimationFrame(mapState.animationFrame);
          mapState.animationFrame = null;
        }
        hideOrbMarker();
      });
    </script>
  </body>
</html>
